! ════════════════════════════════════════════════════════════════
! showcase.hl — Pokazowy plik Hacker Lang
! wszystkie dostępne funkcje składni
! HackerOS / hacker-lang
! ════════════════════════════════════════════════════════════════

! ── Zależności systemowe ─────────────────────────────────────────
// curl git jq tar find grep sed awk

! ── Biblioteki ───────────────────────────────────────────────────
#<source/utils>
#<source/tui>
#<core/io:1.0.0>
#<bytes/crypto>
#<github/hackeros/toolkit:2.1.0>

! ── Importy z przestrzenią nazw ──────────────────────────────────
<< "libs/math.hl"    in math
<< "libs/strings.hl" in str
<< "libs/fs.hl"      in fs

! ── Stałe środowiskowe ───────────────────────────────────────────
@APP_NAME    = "HackerOS Showcase"
@APP_VERSION = "1.0.0"
@BUILD_DIR   = "/tmp/hackeros/build"
@LOG_FILE    = "/var/log/hackeros/showcase.log"
@MAX_RETRY   = "3"

!!
Blok komentarza wieloliniowego
Tutaj można pisać dowolnie
Dokumentacja, notatki, TODO itp.
!!

! ════════════════════════════════════════════════════════════════
! ENUMY I STRUKTURY
! ════════════════════════════════════════════════════════════════

== Status     [ OK, ERR, PENDING, TIMEOUT ]
== LogLevel   [ DEBUG, INFO, WARN, ERROR ]
== BuildType  [ DEBUG, RELEASE, TEST ]

struct Config [
  host:str,
  port:int,
  debug:bool,
  version:str
]

struct User [
  id:int,
  name:str,
  role:str,
  active:bool
]

struct BuildResult [
  code:int,
  output:str,
  duration:str
]

! ════════════════════════════════════════════════════════════════
! KLASA — App
! ════════════════════════════════════════════════════════════════

;; App def

  ! ── Funkcja inicjalizacji ──────────────────────────────────────
  : init [str -> void] def
    log "App.init: $APP_NAME v$APP_VERSION"
    > mkdir -p $BUILD_DIR
    > mkdir -p $(dirname $LOG_FILE)

    ? ! -d $BUILD_DIR > end 1

    .App.load_config $1
    .App.check_deps
  done

  ! ── Wczytaj konfigurację ───────────────────────────────────────
  : load_config [str -> void] def
    config_file = $1

    ? ! -f $config_file |>
      log "Brak pliku konfiguracji — używam domyślnych"
      @HOST  = "localhost"
      @PORT  = "8080"
      @DEBUG = "false"
      end

    @HOST  = $(jq -r '.host'  $config_file)
    @PORT  = $(jq -r '.port'  $config_file)
    @DEBUG = $(jq -r '.debug' $config_file)

    log "Konfiguracja: $HOST:$PORT debug=$DEBUG"
  done

  ! ── Sprawdź zależności ─────────────────────────────────────────
  : check_deps [-> void] def
    log "Sprawdzam zależności..."

    for dep in "curl git jq tar" |>
      ? ! $(command -v $dep) |>
        log "Brak: $dep"
        end 1
      log "OK: $dep"

    log "Wszystkie zależności OK"
  done

  ! ── Główna pętla ───────────────────────────────────────────────
  : run [-> void] def
    log "App.run start"

    .App.init "/etc/hackeros/config.json"

    ? $DEBUG == "true" > .App.print_banner

    try .App.main_logic catch .App.on_error

    log "App.run koniec"
    end 0
  done

  ! ── Logika główna ──────────────────────────────────────────────
  : main_logic [-> void] def
    .App.fetch_data
    .App.process
    .App.report
  done

  ! ── Banner ─────────────────────────────────────────────────────
  : print_banner [-> void] def
    > echo "══════════════════════════════"
    > echo " $APP_NAME v$APP_VERSION"
    > echo " Host: $HOST:$PORT"
    > echo " Build: $BUILD_DIR"
    > echo "══════════════════════════════"
  done

  ! ── Obsługa błędów ─────────────────────────────────────────────
  : on_error [-> void] def
    log "Błąd krytyczny w App.main_logic"
    > echo "Sprawdź logi: $LOG_FILE"
    end 1
  done

done

! ════════════════════════════════════════════════════════════════
! KLASA — Network
! ════════════════════════════════════════════════════════════════

;; Network def

  ! ── Pobierz dane z API ─────────────────────────────────────────
  : fetch [str -> str] def
    url     = $1
    attempt = 0

    while $attempt < $MAX_RETRY |>
      got = await .http.get $url
      ? $? == 0 > out $got
      attempt = $(( $attempt + 1 ))
      log "Retry $attempt/$MAX_RETRY: $url"
      > sleep 1

    log "Nie udało się pobrać: $url"
    out ""
  done

  ! ── POST z payloadem ───────────────────────────────────────────
  : post [str, str -> str] def
    url     = $1
    payload = $2
    got     = await .http.post $url $payload
    ? $? != 0 > out ""
    out $got
  done

  ! ── Sprawdź połączenie ─────────────────────────────────────────
  : ping [str -> bool] def
    > ping -c1 -W1 $1 > /dev/null 2>&1
    ? $? == 0 > out "true"
    out "false"
  done

done

! ════════════════════════════════════════════════════════════════
! KLASA — Builder
! ════════════════════════════════════════════════════════════════

;; Builder def

  ! ── Kompiluj projekt ───────────────────────────────────────────
  : build [str -> int] def
    target = $1
    log "Builder.build: $target"

    ? $target == "release" |>
      > cargo build --release 2>&1 | tee $LOG_FILE
      out $?

    ? $target == "debug" |>
      > cargo build 2>&1 | tee $LOG_FILE
      out $?

    ? $target == "test" |>
      > cargo test 2>&1 | tee $LOG_FILE
      out $?

    log "Nieznany target: $target"
    out 1
  done

  ! ── Wyczyść artefakty ──────────────────────────────────────────
  : clean [-> void] def
    log "Builder.clean"
    > rm -rf $BUILD_DIR/target
    > rm -rf $BUILD_DIR/tmp
    > mkdir -p $BUILD_DIR
    log "Wyczyszczono"
  done

  ! ── Pełny pipeline ─────────────────────────────────────────────
  : pipeline [str -> void] def
    log "Pipeline start: $1"

    .Builder.clean

    code = .Builder.build $1
    ? $code != 0 |>
      log "Build failed: $code"
      end 1

    .Builder.package $1
    .Builder.deploy

    log "Pipeline OK"
  done

  ! ── Pakuj artefakt ─────────────────────────────────────────────
  : package [str -> void] def
    name = "$APP_NAME-$APP_VERSION-$1"
    log "Package: $name"
    > tar -czf $BUILD_DIR/$name.tar.gz -C $BUILD_DIR/target .
    log "Spakowano: $name.tar.gz"
  done

  ! ── Deploy ─────────────────────────────────────────────────────
  : deploy [-> void] def
    alive = .Network.ping $HOST
    ? $alive != "true" |>
      log "Host niedostępny: $HOST"
      end 1

    log "Deploy → $HOST:$PORT"
    > scp $BUILD_DIR/*.tar.gz $HOST:/opt/hackeros/
    > ssh $HOST "cd /opt/hackeros && ./install.sh"
    log "Deploy OK"
  done

done

! ════════════════════════════════════════════════════════════════
! KLASA — DataProcessor
! ════════════════════════════════════════════════════════════════

;; DataProcessor def

  ! ── Fetch i przetwórz dane ─────────────────────────────────────
  : fetch_data [-> void] def
    log "Pobieram dane..."
    raw = .Network.fetch "https://api.hackeros.dev/v1/data"

    ? $raw == "" |>
      log "Brak danych"
      end 1

    @RAW_DATA = $raw
    log "Pobrano $(echo $raw | wc -c) bajtów"
  done

  ! ── Przetwórz dane ─────────────────────────────────────────────
  : process [-> void] def
    log "Przetwarzam..."

    count    = $(echo $RAW_DATA | jq '. | length')
    filtered = $(echo $RAW_DATA | jq '[.[] | select(.active == true)]')
    sorted   = $(echo $filtered | jq 'sort_by(.name)')

    @PROCESSED = $sorted
    log "Przetworzono: $count rekordów"
  done

  ! ── Raport ─────────────────────────────────────────────────────
  : report [-> void] def
    log "Generuję raport..."
    > echo $PROCESSED | jq -r '.[] | "\(.id)\t\(.name)\t\(.role)"'
    > echo "---"
    > echo "Łącznie: $(echo $PROCESSED | jq '. | length') aktywnych"
  done

done

! ════════════════════════════════════════════════════════════════
! KLASA — FileManager (unsafe — operacje na plikach systemowych)
! ════════════════════════════════════════════════════════════════

;; FileManager def

  ! ── Odczyt pliku ───────────────────────────────────────────────
  : read [str -> str] def
    ? ! -f $1 > out ""
    got = $(cat $1)
    out $got
  done

  ! ── Zapis pliku ────────────────────────────────────────────────
  : write [str, str -> void] def
    path    = $1
    content = $2
    > mkdir -p $(dirname $path)
    >> echo "$content" > $path
  done

  ! ── Backup ─────────────────────────────────────────────────────
  : backup [str -> void] def
    src  = $1
    dest = "$1.bak.$(date +%Y%m%d_%H%M%S)"
    ? ! -f $src > out ""
    > cp $src $dest
    log "Backup: $dest"
  done

  ! ── Usuń z sudo ────────────────────────────────────────────────
  :: purge [str -> void] def
    path = $1
    log "Purge: $path"
    ^rm -rf $path
    log "Usunięto: $path"
  done

  ! ── Szukaj plików ──────────────────────────────────────────────
  : find_files [str, str -> str] def
    dir     = $1
    pattern = $2
    got     = $(find $dir -name "$pattern" -type f 2>/dev/null)
    out $got
  done

done

! ════════════════════════════════════════════════════════════════
! KLASA — Monitor (TUI)
! ════════════════════════════════════════════════════════════════

;; Monitor def

  @MON_RUNNING = "false"

  : start [-> void] def
    .tui.init
    .tui.title "$APP_NAME — Monitor"
    .tui.statusbar "q — wyjście  r — odśwież  b — build"

    @MON_RUNNING = "true"
    .Monitor.render
    .tui.run "Monitor.on_key"
    .tui.done
  done

  : render [-> void] def
    cpu   = $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d. -f1)
    ram   = $(free | awk '/Mem:/ {printf "%d", $3/$2*100}')
    disk  = $(df / | awk 'NR==2 {print $5}' | tr -d '%')
    uptime = $(uptime -p)

    .widgets.box 3 2 12 45 "System"
    .widgets.progress 5  4 35 $cpu  "CPU  "
    .widgets.progress 7  4 35 $ram  "RAM  "
    .widgets.progress 9  4 35 $disk "DISK "
    .widgets.label 11 4 "Uptime: $uptime" "cyan"

    .widgets.box 3 49 12 30 "Akcje"
    .widgets.menu 5 51 "Build Release|Build Debug|Clean|Deploy|Wyjście"
  done

  : on_key [str -> void] def
    key = $1

    ? $key == "71" |>
      @MON_RUNNING = "false"

    ? $key == "72" |>
      .Monitor.render
      .tui.statusbar "Odświeżono"

    ? $key == "62" |>
      .tui.statusbar "Buduję..."
      & .Builder.build "release"
      .tui.statusbar "Build w tle..."

    ? $key == "41415b41" > .widgets.menu_up
    ? $key == "41415b42" > .widgets.menu_down 5

    ? $key == "0a" |>
      ? $MENU_SELECTED == "0" > & .Builder.pipeline "release"
      ? $MENU_SELECTED == "1" > & .Builder.pipeline "debug"
      ? $MENU_SELECTED == "2" > .Builder.clean
      ? $MENU_SELECTED == "3" > & .Builder.deploy
      ? $MENU_SELECTED == "4" > @MON_RUNNING = "false"
  done

done

! ════════════════════════════════════════════════════════════════
! KLASA — Jobs (blokady i współbieżność)
! ════════════════════════════════════════════════════════════════

;; Jobs def

  : run_all [-> void] def
    log "Uruchamiam równoległe zadania..."

    lock $JOB_BUILD   = "running"
    lock $JOB_FETCH   = "running"
    lock $JOB_ANALYZE = "running"

    & .Jobs.build_job
    & .Jobs.fetch_job
    & .Jobs.analyze_job

    .Jobs.wait_all
    log "Wszystkie zadania zakończone"
  done

  : build_job [-> void] def
    log "build_job start"
    .Builder.build "release"
    lock $JOB_BUILD = "done"
    log "build_job done"
  done

  : fetch_job [-> void] def
    log "fetch_job start"
    .DataProcessor.fetch_data
    lock $JOB_FETCH = "done"
    log "fetch_job done"
  done

  : analyze_job [-> void] def
    log "analyze_job start"
    .DataProcessor.process
    lock $JOB_ANALYZE = "done"
    log "analyze_job done"
  done

  : wait_all [-> void] def
    while $JOB_BUILD != "done" |>
      > sleep 0.5
    while $JOB_FETCH != "done" |>
      > sleep 0.5
    while $JOB_ANALYZE != "done" |>
      > sleep 0.5

    unlock $JOB_BUILD
    unlock $JOB_FETCH
    unlock $JOB_ANALYZE
  done

done

! ════════════════════════════════════════════════════════════════
! KLASA — Plugin (zewnętrzne rozszerzenia)
! ════════════════════════════════════════════════════════════════

;; Plugins def

  : run_all [-> void] def
    log "Uruchamiam pluginy..."
    \\ docker-build --prod --tag $APP_NAME:$APP_VERSION
    \\ notify-send "Build zakończony"
    \\ slack-notify "#devops" "Deploy $APP_NAME $APP_VERSION OK"
  done

  : run_sudo [-> void] def
    log "Plugin z uprawnieniami..."
    ^\\ system-update --force
    ^\\ firewall-reload
  done

done

! ════════════════════════════════════════════════════════════════
! KLASA — Linker (zewnętrzne biblioteki binarne)
! ════════════════════════════════════════════════════════════════

;; Linker def

  : setup [-> void] def
    -- libssl.so
    -- libcrypto.so
    -- static libmusl.a
    -- static libhackeros-core.a
  done

done

! ════════════════════════════════════════════════════════════════
! FUNKCJE GLOBALNE (poza klasami)
! ════════════════════════════════════════════════════════════════

! ── Blok raw — skrypt shell bez parsowania HL ─────────────────
: raw_example [-> void] def
  [
    #!/usr/bin/env bash
    for i in $(seq 1 5); do
      echo "raw line $i"
    done
    RESULT=$(date +%s)
    echo "timestamp: $RESULT"
  ]
done

! ── Try/catch ─────────────────────────────────────────────────
: safe_build [-> void] def
  try .Builder.pipeline "release" catch handle_build_error
done

: handle_build_error [-> void] def
  log "Build error — czyszczę i próbuję ponownie"
  .Builder.clean
  try .Builder.build "debug" catch fatal_error
done

: fatal_error [-> void] def
  log "Fatal — nie można zbudować projektu"
  > echo "Sprawdź: $LOG_FILE"
  end 1
done

! ── Pętle ─────────────────────────────────────────────────────
: loop_examples [-> void] def
  ! pętla stała — 5 razy
  = 5 > echo "iteracja"

  ! pętla while
  counter = 0
  while $counter < 10 |>
    > echo "counter: $counter"
    counter = $(( $counter + 1 ))

  ! pętla for po liście
  for item in "alpha beta gamma delta" |>
    > echo "item: $item"

  ! pętla for po plikach
  for file in $(ls $BUILD_DIR) |>
    log "Plik: $file"
done

! ── Warunki złożone ───────────────────────────────────────────
: conditions [str, int -> str] def
  name = $1
  code = $2

  ? $code == 0  > out "OK: $name"
  ?? $code == 1 > out "WARN: $name"
  ?? $code == 2 > out "ERR: $name"
  ?: > out "UNKNOWN: $name — code=$code"
done

! ── Zmienne lokalne / globalne / raw ──────────────────────────
: var_examples [-> void] def
  ! lokalna
  local_var = "tylko tutaj"

  ! globalna (export do env)
  @GLOBAL_VAR = "widoczna wszędzie"

  ! raw (bez interpolacji $)
  ~raw_var = $(cat /etc/os-release)

  ! z podstawieniem komendy
  timestamp = $(date +%Y-%m-%d_%H:%M:%S)
  hostname  = $(hostname -f)
  kernel    = $(uname -r)

  log "host=$hostname kernel=$kernel ts=$timestamp"
done

! ── Komendy w różnych trybach ─────────────────────────────────
: cmd_examples [-> void] def
  ! zwykła komenda shell (z podstawieniem $)
  > echo "Wersja: $APP_VERSION"

  ! bez podstawień
  >> echo "Literal: $PATH nie zostanie zamienione"

  ! izolowana (osobny proces/środowisko)
  >>> env -i HOME=/tmp bash -c "echo izolowane"

  ! w tle
  & find / -name "*.hl" > /tmp/hl_files.txt

  ! z pipe (operator |>)
  |> grep "error" $LOG_FILE

  ! odwrócony pipe
  <| sort -u /tmp/hl_files.txt
done

! ── Log ───────────────────────────────────────────────────────
: log_examples [-> void] def
  log "Zwykła wiadomość"
  log "Wersja: $APP_VERSION"
  log "Build dir: $BUILD_DIR"
done

! ── Out (return wartości) ──────────────────────────────────────
: math_example [int, int -> int] def
  a      = $1
  b      = $2
  result = $(( $a + $b * 2 ))
  out $result
done

: string_example [str -> str] def
  input  = $1
  upper  = $(echo $input | tr '[:lower:]' '[:upper:]')
  out "RESULT: $upper"
done

! ── Await ─────────────────────────────────────────────────────
: async_example [-> void] def
  log "Pobieranie równoległe..."

  got_a = await .Network.fetch "https://api.hackeros.dev/v1/users"
  got_b = await .Network.fetch "https://api.hackeros.dev/v1/posts"

  > echo "Users: $(echo $got_a | jq '. | length')"
  > echo "Posts: $(echo $got_b | jq '. | length')"
done

! ════════════════════════════════════════════════════════════════
! MAIN — punkt wejścia programu
! ════════════════════════════════════════════════════════════════

: main [-> void] def
  log "START $APP_NAME v$APP_VERSION"

  ! sprawdź argumenty
  mode = $1

  ? $mode == ""        > mode = "run"
  ? $mode == "monitor" > .Monitor.start
  ? $mode == "build"   > .Builder.pipeline $2
  ? $mode == "clean"   > .Builder.clean
  ? $mode == "deploy"  > .Builder.deploy
  ? $mode == "jobs"    > .Jobs.run_all
  ? $mode == "plugins" > .Plugins.run_all
  ? $mode == "test"    > .safe_build
  ? $mode == "run"     > .App.run

  log "KONIEC"
  end 0
done

.main $@
