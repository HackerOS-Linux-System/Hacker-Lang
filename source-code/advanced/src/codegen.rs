use crate::ast_parser::{Node, BinaryOp};
use crate::semantics::{Type, TypeMap};
use indextree::{Arena, NodeId};
use miette::Result;

// Kontekst generowania kodu
struct GenContext<'a> {
    arena: &'a Arena<Node>,
    types: &'a TypeMap,
    mode: String,
    // Stos zakresów: każdy element to lista zmiennych (nazwa, typ) zadeklarowanych w danym bloku
    scope_stack: Vec<Vec<(String, Type)>>,
}

impl<'a> GenContext<'a> {
    fn new(arena: &'a Arena<Node>, types: &'a TypeMap, mode: String) -> Self {
        Self {
            arena,
            types,
            mode,
            scope_stack: vec![],
        }
    }

    fn push_scope(&mut self) {
        self.scope_stack.push(vec![]);
    }

    fn pop_scope(&mut self, code: &mut String) {
        if let Some(vars) = self.scope_stack.pop() {
            // Jeśli jesteśmy w trybie Safe, generujemy decref dla obiektów
            if self.mode == "safe" {
                for (name, ty) in vars.iter().rev() {
                    if let Type::Object(_) = ty {
                        code.push_str(&format!("    hla_decref({});\n", sanitize_name(name)));
                    }
                }
            }
        }
    }

    fn register_var(&mut self, name: String, ty: Type) {
        if let Some(scope) = self.scope_stack.last_mut() {
            scope.push((name, ty));
        }
    }
}

fn sanitize_name(name: &str) -> String {
    match name {
        "auto" | "break" | "case" | "char" | "const" | "continue" | "default" | "do" | "double" | "else" | "enum" | "extern" |
        "float" | "for" | "goto" | "if" | "int" | "long" | "register" | "return" | "short" | "signed" | "sizeof" | "static" |
        "struct" | "switch" | "typedef" | "union" | "unsigned" | "void" | "volatile" | "while" => format!("{}_", name),
        _ => name.to_string(),
    }
}

pub fn generate_c(arena: &Arena<Node>, root: NodeId, types: &TypeMap) -> Result<String> {
    let mut code = String::new();
    let root_data = arena.get(root).unwrap().get();
    let mode = if let Node::Program(m) = root_data { m.clone() } else { "automatic".to_string() };

    let mut ctx = GenContext::new(arena, types, mode.clone());

    // 1. Headers & Helper Macros
    code.push_str("/* Generated by HLA-Advanced Compiler */\n");
    code.push_str("#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n");

    code.push_str("#define LOG_INFO(fmt, ...) fprintf(stdout, \"[INFO] \" fmt, ##__VA_ARGS__)\n");
    code.push_str("#define LOG_ERROR(fmt, ...) fprintf(stderr, \"[ERROR] \" fmt, ##__VA_ARGS__)\n\n");

    // 2. Memory Management Strategy
    code.push_str(&format!("// Memory Mode: {}\n", mode));

    match mode.as_str() {
        "safe" => {
            // Simple Reference Counting
            code.push_str("typedef struct { int rc; } HLA_Header;\n");
            code.push_str("void* hla_alloc(size_t size) {\n");
            code.push_str("    HLA_Header* h = (HLA_Header*)malloc(sizeof(HLA_Header) + size);\n");
            code.push_str("    if(!h) { LOG_ERROR(\"OOM\\n\"); exit(1); }\n");
            code.push_str("    h->rc = 1; // Initial ref count is 1 (ownership)\n");
            code.push_str("    return (void*)(h + 1);\n");
            code.push_str("}\n");
            code.push_str("void hla_incref(void* ptr) {\n");
            code.push_str("    if(!ptr) return;\n");
            code.push_str("    HLA_Header* h = (HLA_Header*)ptr - 1;\n");
            code.push_str("    h->rc++;\n");
            code.push_str("}\n");
            code.push_str("void hla_decref(void* ptr) {\n");
            code.push_str("    if(!ptr) return;\n");
            code.push_str("    HLA_Header* h = (HLA_Header*)ptr - 1;\n");
            code.push_str("    h->rc--;\n");
            code.push_str("    if(h->rc == 0) free(h);\n");
            code.push_str("}\n");
        },
        "manual" => {
            code.push_str("void* hla_alloc(size_t size) { return malloc(size); }\n");
            code.push_str("#define hla_free free\n");
        },
        _ => { // Auto / Automatic - Dynamic Arena
            code.push_str("// Dynamic Arena Allocator\n");
            code.push_str("typedef struct ArenaBlock { char* data; size_t used; size_t cap; struct ArenaBlock* next; } ArenaBlock;\n");
            code.push_str("static ArenaBlock* arena_head = NULL;\n");
            code.push_str("void* hla_alloc(size_t size) {\n");
            code.push_str("    if (!arena_head || arena_head->used + size > arena_head->cap) {\n");
            code.push_str("        size_t new_cap = size > 4096 ? size : 4096;\n");
            code.push_str("        ArenaBlock* b = (ArenaBlock*)malloc(sizeof(ArenaBlock));\n");
            code.push_str("        b->data = (char*)malloc(new_cap);\n");
            code.push_str("        b->used = 0; b->cap = new_cap; b->next = arena_head; arena_head = b;\n");
            code.push_str("    }\n");
            code.push_str("    void* ptr = arena_head->data + arena_head->used;\n");
            code.push_str("    arena_head->used += size;\n");
            code.push_str("    return ptr;\n");
            code.push_str("}\n");
            code.push_str("void hla_cleanup() {\n");
            code.push_str("    while(arena_head) { ArenaBlock* n = arena_head->next; free(arena_head->data); free(arena_head); arena_head = n; }\n");
            code.push_str("}\n");
        }
    }
    code.push_str("\n");

    // 3. PASS 1: Struct Definitions
    for child in root.children(arena) {
        if let Node::Object { name, body } = arena.get(child).unwrap().get() {
            let s_name = sanitize_name(name);
            code.push_str(&format!("typedef struct {} {};\n", s_name, s_name));
            code.push_str(&format!("struct {} {{\n", s_name));
            for field in body.children(arena) {
                if let Node::Var { name: f_name, value_id, .. } = arena.get(field).unwrap().get() {
                    let f_type = types.get(value_id).unwrap_or(&Type::Int);
                    let c_type = map_type_to_c(f_type);
                    code.push_str(&format!("    {} {};\n", c_type, sanitize_name(f_name)));
                }
            }
            code.push_str("};\n\n");
        }
    }

    // 4. PASS 2: Function Prototypes
    for child in root.children(arena) {
        if let Node::Func { name, args, .. } = arena.get(child).unwrap().get() {
            code.push_str("int ");
            code.push_str(&sanitize_name(name));
            code.push_str("(");
            if args.is_empty() {
                code.push_str("void");
            } else {
                let arg_defs: Vec<String> = args.iter().map(|a| format!("int {}", sanitize_name(a))).collect(); // Prototypowo int, w przyszlosci TypeMap
                code.push_str(&arg_defs.join(", "));
            }
            code.push_str(");\n");
        }
    }
    code.push_str("\n");

    // 5. PASS 3: Global Variables Declarations
    for child in root.children(arena) {
        let node = arena.get(child).unwrap().get();
        match node {
            Node::Require(file) => code.push_str(&format!("#include \"{}\"\n", file.replace(".hlc", ".h"))),
            Node::Import { source, name, .. } if source == "c" => code.push_str(&format!("#include <{}.h>\n", name)),
            Node::Var { name, value_id } => {
                let ty = types.get(value_id).unwrap_or(&Type::Int);
                code.push_str(&format!("{} {};\n", map_type_to_c(ty), sanitize_name(name)));
            },
            _ => {}
        }
    }

    // 6. PASS 4: Function Implementations
    for child in root.children(arena) {
        if let Node::Func { .. } = arena.get(child).unwrap().get() {
            generate_node(child, &mut ctx, &mut code, true)?;
        }
    }

    // 7. Main Function
    code.push_str("\nint main(int argc, char** argv) {\n");
    if mode == "automatic" || mode == "auto" {
        code.push_str("    atexit(hla_cleanup);\n");
    }

    // Initializacja globali
    for child in root.children(arena) {
        if let Node::Var { name, value_id } = arena.get(child).unwrap().get() {
            code.push_str(&format!("    {} = ", sanitize_name(name)));
            emit_expr(*value_id, arena, &mut code, types)?;
            code.push_str(";\n");
        }
    }

    // Reszta kodu w main
    for child in root.children(arena) {
        let node = arena.get(child).unwrap().get();
        match node {
            Node::Func { .. } | Node::Object { .. } | Node::Require(_) | Node::Import{..} | Node::Var{..} => {},
            _ => generate_node(child, &mut ctx, &mut code, false)?,
        }
    }

    code.push_str("    return 0;\n}\n");
    Ok(code)
}

fn map_type_to_c(ty: &Type) -> String {
    match ty {
        Type::Int => "int".to_string(),
        Type::String => "char*".to_string(),
        Type::Void => "void".to_string(),
        Type::Object(name) => format!("{}*", sanitize_name(name)),
        Type::Unknown => "int".to_string(),
    }
}

fn generate_node(id: NodeId, ctx: &mut GenContext, code: &mut String, is_global: bool) -> Result<()> {
    let node = ctx.arena.get(id).unwrap().get();

    match node {
        Node::Func { name, args, body } => {
            code.push_str(&format!("int {}(", sanitize_name(name)));
            if args.is_empty() {
                code.push_str("void");
            } else {
                let arg_defs: Vec<String> = args.iter().map(|a| format!("int {}", sanitize_name(a))).collect();
                code.push_str(&arg_defs.join(", "));
            }
            code.push_str(") {\n");

            ctx.push_scope(); // Zakres funkcji
            for child in body.children(ctx.arena) {
                generate_node(child, ctx, code, false)?;
            }
            ctx.pop_scope(code); // Clean up locals

            code.push_str("    return 0;\n}\n");
        },
        Node::Call { name, args_ids } => {
            code.push_str("    ");
            code.push_str(&sanitize_name(name));
            code.push_str("(");
            for (i, arg_id) in args_ids.iter().enumerate() {
                if i > 0 { code.push_str(", "); }
                emit_expr(*arg_id, ctx.arena, code, ctx.types)?;
            }
            code.push_str(");\n");
        },
        Node::MethodCall { object, method, args_ids } => {
            // Transformacja obj.method(x) -> ObjectType_method(obj, x)
            // Hack: Znajdujemy typ zmiennej `object` iterując po scope_stack
            let mut struct_name = "Unknown".to_string();
            'search: for scope in ctx.scope_stack.iter().rev() {
                for (name, ty) in scope {
                    if name == object {
                        if let Type::Object(s) = ty {
                            struct_name = s.clone();
                            break 'search;
                        }
                    }
                }
            }

            code.push_str("    ");
            code.push_str(&format!("{}_{}", sanitize_name(&struct_name), sanitize_name(method)));
            code.push_str("(");
            code.push_str(&sanitize_name(object)); // self jako pierwszy argument
            if !args_ids.is_empty() {
                code.push_str(", ");
            }
            for (i, arg_id) in args_ids.iter().enumerate() {
                if i > 0 { code.push_str(", "); }
                emit_expr(*arg_id, ctx.arena, code, ctx.types)?;
            }
            code.push_str(");\n");
        },
        Node::Log(arg_id) => {
            let arg_type = ctx.types.get(arg_id).unwrap_or(&Type::Int);
            code.push_str("    LOG_INFO(\"");
            match arg_type {
                Type::String => code.push_str("%s\\n\", "),
                _ => code.push_str("%d\\n\", "),
            }
            emit_expr(*arg_id, ctx.arena, code, ctx.types)?;
            code.push_str(");\n");
        },
        Node::Var { name, value_id } => {
            if is_global { return Ok(()); }
            let ty = ctx.types.get(value_id).unwrap_or(&Type::Int);
            code.push_str(&format!("    {} {} = ", map_type_to_c(ty), sanitize_name(name)));
            emit_expr(*value_id, ctx.arena, code, ctx.types)?;
            code.push_str(";\n");

            ctx.register_var(name.clone(), ty.clone());

            if ctx.mode == "safe" {
                if let Type::Object(_) = ty {
                    let val_node = ctx.arena.get(*value_id).unwrap().get();
                    if let Node::Ident(_) = val_node {
                        code.push_str(&format!("    hla_incref({});\n", sanitize_name(name)));
                    }
                }
            }
        },
        Node::Assign { name, value_id } => {
            // Zakładamy, że zmienna istnieje (sprawdzone w semantyce)
            code.push_str(&format!("    {} = ", sanitize_name(name)));
            emit_expr(*value_id, ctx.arena, code, ctx.types)?;
            code.push_str(";\n");
        },
        Node::FieldAssign { object, field, value_id } => {
            // object->field = value
            code.push_str(&format!("    {}->{} = ", sanitize_name(object), sanitize_name(field)));
            emit_expr(*value_id, ctx.arena, code, ctx.types)?;
            code.push_str(";\n");
        },
        Node::Block => {
            code.push_str("{\n");
            ctx.push_scope();
            for child in id.children(ctx.arena) {
                generate_node(child, ctx, code, false)?;
            }
            ctx.pop_scope(code);
            code.push_str("}\n");
        },
        _ => {}
    }
    Ok(())
}

fn emit_expr(id: NodeId, arena: &Arena<Node>, code: &mut String, types: &TypeMap) -> Result<()> {
    let node = arena.get(id).unwrap().get();
    match node {
        Node::StringLit(s) => code.push_str(&format!("\"{}\"", s)),
        Node::IntLit(i) => code.push_str(&i.to_string()),
        Node::Ident(s) => code.push_str(&sanitize_name(s)),
        Node::BinaryOp { op, lhs, rhs } => {
            code.push_str("(");
            emit_expr(*lhs, arena, code, types)?;
            match op {
                BinaryOp::Add => code.push_str(" + "),
                BinaryOp::Sub => code.push_str(" - "),
                BinaryOp::Mul => code.push_str(" * "),
                BinaryOp::Div => code.push_str(" / "),
            }
            emit_expr(*rhs, arena, code, types)?;
            code.push_str(")");
        },
        Node::Call { name, args_ids } => {
            code.push_str(&sanitize_name(name));
            code.push_str("(");
            for (i, arg_id) in args_ids.iter().enumerate() {
                if i > 0 { code.push_str(", "); }
                emit_expr(*arg_id, arena, code, types)?;
            }
            code.push_str(")");
        },
        Node::MethodCall { object, method, args_ids } => {
            // W wyrażeniach nie mamy dostępu do scope_stack żeby zgadnąć typ 'object'.
            code.push_str(&format!("{}_{}({}", "UnknownStruct", sanitize_name(method), sanitize_name(object)));
            for arg_id in args_ids {
                code.push_str(", ");
                emit_expr(*arg_id, arena, code, types)?;
            }
            code.push_str(")");
        },
        Node::FieldAccess { object, field } => {
            // object->field
            code.push_str(&format!("{}->{}", sanitize_name(object), sanitize_name(field)));
        },
        _ => code.push_str("0"),
    }
    Ok(())
}
