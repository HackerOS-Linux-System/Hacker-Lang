use crate::ast_parser::{Node, BinaryOp};
use crate::semantics::{Type, TypeMap};
use indextree::{Arena, NodeId};
use miette::Result;

pub fn generate_c(arena: &Arena<Node>, root: NodeId, types: &TypeMap) -> Result<String> {
    let mut code = String::new();
    let root_data = arena.get(root).unwrap().get();

    // 1. Headers & Helper Macros
    code.push_str("/* Generated by HLA-Advanced Compiler */\n");
    code.push_str("#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n");

    // Logging System
    code.push_str("#define LOG_INFO(fmt, ...) fprintf(stdout, \"[INFO] \" fmt, ##__VA_ARGS__)\n");
    code.push_str("#define LOG_ERROR(fmt, ...) fprintf(stderr, \"[ERROR] \" fmt, ##__VA_ARGS__)\n\n");

    // 2. Memory Management Strategy
    if let Node::Program(mode) = root_data {
        code.push_str(&format!("// Memory Mode: {}\n", mode));

        match mode.as_str() {
            "safe" => {
                code.push_str("typedef struct { int ref_count; void* ptr; } RefObj;\n");
                code.push_str("void* hla_alloc(size_t size) { void* p = malloc(size); return p; }\n");
            },
            "manual" => {
                code.push_str("void* hla_alloc(size_t size) { return malloc(size); }\n");
                code.push_str("#define hla_free free\n");
            },
            _ => { // Auto
                code.push_str("// Simple Linear Allocator (Arena stub)\n");
                code.push_str("#define HEAP_SIZE 1024 * 1024\n");
                code.push_str("static char heap[HEAP_SIZE];\n");
                code.push_str("static size_t heap_ptr = 0;\n");
                code.push_str("void* hla_alloc(size_t size) {\n");
                code.push_str("    if(heap_ptr + size > HEAP_SIZE) { LOG_ERROR(\"OOM\\n\"); exit(1); }\n");
                code.push_str("    void* ptr = &heap[heap_ptr]; heap_ptr += size; return ptr;\n");
                code.push_str("}\n");
            }
        }
    }
    code.push_str("\n");

    // 3. PASS 1: Struct Definitions
    for child in root.children(arena) {
        if let Node::Object { name, body } = arena.get(child).unwrap().get() {
            code.push_str(&format!("typedef struct {} {};\n", name, name));
            code.push_str(&format!("struct {} {{\n", name));
            for field in body.children(arena) {
                if let Node::Var { name: f_name, value_id, .. } = arena.get(field).unwrap().get() {
                    let f_type = types.get(value_id).unwrap_or(&Type::Int);
                    let c_type = map_type_to_c(f_type);
                    code.push_str(&format!("    {} {};\n", c_type, f_name));
                }
            }
            code.push_str("};\n\n");
        }
    }

    // 4. PASS 2: Function Prototypes
    for child in root.children(arena) {
        if let Node::Func { name, args, .. } = arena.get(child).unwrap().get() {
            code.push_str("int ");
            code.push_str(name);
            code.push_str("(");
            if args.is_empty() {
                code.push_str("void");
            } else {
                let arg_defs: Vec<String> = args.iter().map(|a| format!("int {}", a)).collect();
                code.push_str(&arg_defs.join(", "));
            }
            code.push_str(");\n");
        }
    }
    code.push_str("\n");

    // 5. PASS 3: Global Variables Declarations
    for child in root.children(arena) {
        let node = arena.get(child).unwrap().get();
        match node {
            Node::Require(file) => code.push_str(&format!("#include \"{}\"\n", file.replace(".hlc", ".h"))),
            Node::Import { source, name, .. } if source == "c" => code.push_str(&format!("#include <{}.h>\n", name)),
            Node::Var { name, value_id } => {
                let ty = types.get(value_id).unwrap_or(&Type::Int);
                code.push_str(&format!("{} {};\n", map_type_to_c(ty), name));
            },
            _ => {}
        }
    }

    // 6. PASS 4: Function Implementations
    for child in root.children(arena) {
        if let Node::Func { .. } = arena.get(child).unwrap().get() {
            generate_node(child, arena, &mut code, true, types)?;
        }
    }

    // 7. Main Function (Code generation)
    code.push_str("\nint main(int argc, char** argv) {\n");
    for child in root.children(arena) {
        let node = arena.get(child).unwrap().get();
        match node {
            Node::Func { .. } | Node::Object { .. } | Node::Require(_) | Node::Import{..} => {},
            Node::Var { name, value_id } => {
                // Initializacja zmiennej globalnej
                code.push_str(&format!("    {} = ", name));
                emit_expr(*value_id, arena, &mut code, types)?;
                code.push_str(";\n");
            },
            _ => generate_node(child, arena, &mut code, false, types)?,
        }
    }

    code.push_str("    return 0;\n}\n");
    Ok(code)
}

fn map_type_to_c(ty: &Type) -> String {
    match ty {
        Type::Int => "int".to_string(),
        Type::String => "char*".to_string(),
        Type::Void => "void".to_string(),
        Type::Object(name) => format!("{}*", name),
        Type::Unknown => "int".to_string(),
    }
}

fn generate_node(id: NodeId, arena: &Arena<Node>, code: &mut String, is_global: bool, types: &TypeMap) -> Result<()> {
    let node = arena.get(id).unwrap().get();
    match node {
        Node::Func { name, args, body } => {
            code.push_str(&format!("int {}(", name));
            if args.is_empty() {
                code.push_str("void");
            } else {
                let arg_defs: Vec<String> = args.iter().map(|a| format!("int {}", a)).collect();
                code.push_str(&arg_defs.join(", "));
            }
            code.push_str(") {\n");
            for child in body.children(arena) {
                generate_node(child, arena, code, false, types)?;
            }
            code.push_str("    return 0;\n}\n");
        },
        Node::Call { name, args_ids } => {
            code.push_str("    ");
            code.push_str(name);
            code.push_str("(");
            for (i, arg_id) in args_ids.iter().enumerate() {
                if i > 0 { code.push_str(", "); }
                emit_expr(*arg_id, arena, code, types)?;
            }
            code.push_str(");\n");
        },
        Node::Log(arg_id) => {
            let arg_type = types.get(arg_id).unwrap_or(&Type::Int);
            code.push_str("    LOG_INFO(\"");
            match arg_type {
                Type::String => code.push_str("%s\\n\", "),
                _ => code.push_str("%d\\n\", "),
            }
            emit_expr(*arg_id, arena, code, types)?;
            code.push_str(");\n");
        },
        Node::Var { name, value_id } => {
            if is_global { return Ok(()); }
            let ty = types.get(value_id).unwrap_or(&Type::Int);
            code.push_str(&format!("    {} {} = ", map_type_to_c(ty), name));
            emit_expr(*value_id, arena, code, types)?;
            code.push_str(";\n");
        },
        Node::Block => {
            // Blok w C nie wymaga specjalnej obsÅ‚ugi dla zmiennych, scope jest zachowany
            for child in id.children(arena) {
                generate_node(child, arena, code, false, types)?;
            }
        },
        _ => {}
    }
    Ok(())
}

fn emit_expr(id: NodeId, arena: &Arena<Node>, code: &mut String, types: &TypeMap) -> Result<()> {
    let node = arena.get(id).unwrap().get();
    match node {
        Node::StringLit(s) => code.push_str(&format!("\"{}\"", s)),
        Node::IntLit(i) => code.push_str(&i.to_string()),
        Node::Ident(s) => code.push_str(s),
        Node::BinaryOp { op, lhs, rhs } => {
            code.push_str("(");
            emit_expr(*lhs, arena, code, types)?;
            match op {
                BinaryOp::Add => code.push_str(" + "),
                BinaryOp::Sub => code.push_str(" - "),
                BinaryOp::Mul => code.push_str(" * "),
                BinaryOp::Div => code.push_str(" / "),
            }
            emit_expr(*rhs, arena, code, types)?;
            code.push_str(")");
        },
        Node::Call { name, args_ids } => {
            code.push_str(name);
            code.push_str("(");
            for (i, arg_id) in args_ids.iter().enumerate() {
                if i > 0 { code.push_str(", "); }
                emit_expr(*arg_id, arena, code, types)?;
            }
            code.push_str(")");
        },
        _ => code.push_str("0"),
    }
    Ok(())
}
