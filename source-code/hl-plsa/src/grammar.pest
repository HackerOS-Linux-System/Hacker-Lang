WHITESPACE = _{ " " | "\t" }
ident    = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_" | "-")* }
number   = @{ ASCII_DIGIT+ }
str_lit  = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
version  = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)* }
lib_name = @{ (ASCII_ALPHANUMERIC | "_" | "-" | "/")+ }
lib_type = @{ "source" | "core" | "bytes" | "github" | "virus" | "vira" }
lib_ref  =  { "<" ~ lib_type ~ "/" ~ lib_name ~ (":" ~ version)? ~ ">" }
rest     = @{ (!EOI ~ ANY)+ }
cond     = @{ (!(" > " | " |> " | " <| ") ~ !EOI ~ ANY)+ }
try_body = @{ (!(" catch ") ~ !EOI ~ ANY)+ }
call_path = @{ ("." ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_" | "-")*)+ }
cpfx      = { "|>" | "<|" | ">" }
type_sig  = { "[" ~ (!"]" ~ ANY)* ~ "]" }

// ── NOWE: pipe_rest — reszta po |> w pipe_stmt ──────────────────
pipe_item = @{ (!(" |> " | EOI) ~ ANY)+ }

// ── NOWE: match_val — wartość ramienia match ─────────────────────
match_val = @{ (!(" > " | " |> " | " <| " | EOI) ~ ANY)+ }

// Reguła line jest wywoływana TYLKO gdy Rust stwierdzi że linia NIE jest przypisaniem
line = { SOI ~ sudo? ~ stmt ~ EOI }
sudo = { "^" }

stmt = {
    class_def    |
    unsafe_def   |
    func_def     |
    func_done    |
    // ── NOWE (najpierw żeby nie pochłonął call_stmt) ─────────────
    spawn_stmt   |
    await_stmt   |
    assert_stmt  |
    match_stmt   |
    match_arm    |
    pipe_stmt    |
    percent_stmt |
    // ── ISTNIEJĄCE (kolejność bez zmian) ─────────────────────────
    call_stmt    |
    sys_dep      |
    lib_stmt     |
    sep_cmd      |
    raw_cmd      |
    expl_cmd     |
    try_stmt     |
    while_stmt   |
    for_stmt     |
    log_stmt     |
    lock_stmt    |
    unlock_stmt  |
    loop_stmt    |
    elif_stmt    |
    else_stmt    |
    if_stmt      |
    bg_stmt      |
    plugin_stmt  |
    extern_stmt  |
    enum_stmt    |
    struct_stmt  |
    import_stmt  |
    raw_blk_s    |
    raw_blk_e    |
    end_stmt     |
    out_stmt
}

// ── ISTNIEJĄCE reguły — BEZ ZMIAN ────────────────────────────────
class_def  = { ";;" ~ ident ~ "def" }
unsafe_def = { "::" ~ ident ~ type_sig? ~ "def" }
func_def   = { ":"  ~ ident ~ type_sig? ~ "def" }
func_done  = { "done" }
call_stmt  = { call_path ~ (rest)? }
sys_dep    = { "//" ~ rest }
lib_stmt   = { "#" ~ lib_ref }
sep_cmd    = { ">>>" ~ rest }
raw_cmd    = { ">>"  ~ rest }
expl_cmd   = { cpfx  ~ rest }
loop_stmt  = { "="   ~ number   ~ cpfx ~ rest }
elif_stmt  = { "??"  ~ cond     ~ cpfx ~ rest }
else_stmt  = { "?:"  ~ cpfx     ~ rest }
if_stmt    = { "?"   ~ cond     ~ cpfx ~ rest }
while_stmt = { "while" ~ cond   ~ cpfx ~ rest }
for_stmt   = { "for" ~ ident ~ "in" ~ cond ~ cpfx ~ rest }
bg_stmt    = { "&"      ~ rest }
log_stmt   = { "log"    ~ str_lit }

lock_key    = { "$" ~ ident }
lock_stmt   = { "lock"   ~ lock_key ~ "=" ~ rest }
unlock_stmt = { "unlock" ~ lock_key }

plugin_stmt = { "\\\\" ~ rest }
extern_stmt = { "--" ~ rest }
enum_stmt   = { "==" ~ ident ~ "[" ~ (ident ~ ("," ~ ident)*)? ~ "]" }
struct_stmt = { "struct" ~ ident ~ "[" ~ (sf ~ ("," ~ sf)*)? ~ "]" }
sf          = { ident ~ ":" ~ ident }
import_stmt = { "<<" ~ str_lit ~ ("in" ~ ident)? }
try_stmt    = { "try" ~ try_body ~ "catch" ~ rest }
raw_blk_s   = { "[" }
raw_blk_e   = { "]" }
end_stmt    = { "end" ~ number? }
out_stmt    = { "out" ~ rest? }

// ── NOWE reguły ───────────────────────────────────────────────────

// % — stała (zamiast const)
// %APP_NAME = "HackerOS"
// %MAX_CONN = 100
percent_key  = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_" | "-")* }
percent_stmt = { "%" ~ percent_key ~ "=" ~ rest }

// spawn — uruchom zadanie asynchronicznie, zwróć handle
// spawn .heavy_task $data
// job = spawn .heavy_task $data   ← obsługiwane przez is_assignment w Rust
spawn_stmt = { "spawn" ~ rest }

// await — czekaj na wynik
// await $job
// result = await $job             ← obsługiwane przez is_assignment w Rust
// result = await .fetch_users     ← obsługiwane przez is_assignment w Rust
await_stmt = { "await" ~ rest }

// assert — walidacja w miejscu
// assert $port > 1024 "Port musi być > 1024"
// assert $file != ""  "Plik nie może być pusty"
// assert -f $path     "Plik nie istnieje"
assert_body = @{ (!("\"" ~ (!EOI ~ ANY)* ~ "\"" ~ EOI | EOI) ~ ANY)+ }
assert_stmt = { "assert" ~ assert_body ~ str_lit? }

// match — dopasowanie wzorców
// match $status |>
//   "ok"  > handle_ok
//   "err" > handle_err
//   _     > handle_unknown
match_stmt = { "match" ~ cond ~ cpfx }
match_arm  = { match_val ~ cpfx ~ rest }

// pipe — łańcuchowanie wywołań
// .fetch_users |> .json.parse |> .list.sort "name" |> .list.take 10
// Uwaga: linie zaczynające się od |> są już obsługiwane przez expl_cmd (cpfx ~ rest)
// pipe_stmt obsługuje wywołanie z WIELOMA |> w jednej linii
pipe_item_sep = _{ " |> " }
pipe_stmt     = { call_path ~ rest? ~ (pipe_item_sep ~ call_path ~ rest?)+ }
