WHITESPACE = _{ " " | "\t" | "\r" | "\n" | line_comment }
line_comment = _{ "!" ~ (!"\n" ~ ANY)* ~ ("\n" | EOI) }
file = { SOI ~ stmt* ~ EOI }
stmt = { sudo? ~ bg? ~ inner_stmt }
sudo = { "^" }
bg = { "&" }
inner_stmt = { assign_global | assign_local | func_def | ret | obj_def | try_stmt | match_stmt | for_indexed | for_stmt | while_stmt | if_stmt | repeat_stmt | break_stmt | continue_stmt | import_stmt | plugin | raw | block | expr_stmt | log_stmt | lock_stmt | unlock_stmt | withlock_stmt | module_stmt | await_stmt }
qual_ident = { ident ~ ("::" ~ ident)* }
ident = { ASCII_ALPHA | "_" ~ (ASCII_ALPHANUMERIC | "_")* }
ty = { ident ~ ("<" ~ ty ~ ("," ~ ty)* ~ ">")? }
expr = { logical_or }
or_op = { "||" }
logical_or = { logical_and ~ (or_op ~ logical_and)* }
and_op = { "&&" }
logical_and = { comparison ~ (and_op ~ comparison)* }
comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }
comparison = { sum ~ (comp_op ~ sum)* }
add_op = { "+" | "-" }
sum = { product ~ (add_op ~ product)* }
mul_op = { "*" | "/" }
product = { pipe ~ (mul_op ~ pipe)* }
pipe_op = { "|>" }
pipe = { atom ~ (pipe_op ~ expr)* }
atom = { lit | call | var | paren_expr | list | map | wildcard }
lit = { float | int | bool_true | bool_false | str | none }
float = { int ~ "." ~ int }
int = { ASCII_DIGIT+ }
bool_true = { "true" }
bool_false = { "false" }
str = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
none = { "none" }
call = { qual_ident ~ "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }
var = { qual_ident }
paren_expr = { "(" ~ expr ~ ")" }
list = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }
map = { "{" ~ (map_entry ~ ("," ~ map_entry)*)? ~ "}" }
map_entry = { ident ~ ":" ~ expr }
wildcard = { "_" }
assign_global = { "@" ~ qual_ident ~ ty_opt ~ "=" ~ expr }
assign_local = { "$" ~ qual_ident ~ ty_opt ~ "=" ~ expr }
ty_opt = { ":" ~ ty ? }
func_def = { func_prefix ~ qual_ident ~ params ~ ret_ty_opt ~ body }
func_prefix = { "::" | ":" }
params = { "(" ~ (param ~ ("," ~ param)*)? ~ ")" }
param = { qual_ident ~ ":" ~ ty }
ret_ty_opt = { "->" ~ ty ? }
body = { "[" ~ stmt* ~ "]" }
ret = { "<-" ~ expr }
field = { "mut"? ~ qual_ident ~ ":" ~ ty ~ ("=" ~ expr)? }
method = { ":" ~ qual_ident ~ params ~ ret_ty_opt ~ body }
obj_def = { ";;" ~ qual_ident ~ "[" ~ (field ~ ("," ~ field)*)? ~ method* ~ "]" }
catch = { "catch" ~ "(" ~ qual_ident ~ ":" ~ qual_ident ~ ")" ~ body }
try_stmt = { "try" ~ body ~ catch* ~ else_body? ~ finally? }
else_body = { "else" ~ body }
finally = { "finally" ~ body }
arm = { (expr | wildcard) ~ body }
match_stmt = { "match" ~ expr ~ "[" ~ arm* ~ "]" }
for_stmt = { "for" ~ qual_ident ~ "in" ~ expr ~ body }
for_indexed = { "for" ~ qual_ident ~ "," ~ qual_ident ~ "in" ~ "enumerate(" ~ expr ~ ")" ~ body }
while_stmt = { "while" ~ expr ~ body }
elif = { "elif" ~ expr ~ body }
if_stmt = { "if" ~ expr ~ body ~ elif* ~ else_body? }
repeat_stmt = { "repeat" ~ int ~ body }
break_stmt = { "break" }
continue_stmt = { "continue" }
import_stmt = { "#" ~ "<" ~ ident ~ "/" ~ (!(":" | ">") ~ ANY)* ~ (":" ~ (! ">" ~ ANY)*)? ~ ">" }
plugin = { "\"" ~ qual_ident }
raw = @{ raw_mode ~ (!"\n" ~ ANY)* }
raw_mode = { ">>>" | ">>" | ">" }
log_stmt = { "log" ~ str }
lock_stmt = { "lock" ~ qual_ident }
unlock_stmt = { "unlock" ~ qual_ident }
withlock_stmt = { "withlock" ~ qual_ident ~ body }
module_stmt = { "module" ~ qual_ident ~ body }
block = { body }
expr_stmt = { expr }
await_stmt = { "await" ~ expr }
